// Decompiled with JetBrains decompiler
// Type: ‌‌⁮‎‫‍⁫‏⁯‏‍⁪‏⁪‬‮‬⁯⁫⁯​⁭‪⁯‮⁪⁯‍⁫⁮‫‏⁪⁫⁮⁪⁯⁮⁯‏‮`2
// Assembly: ExCard, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D8B94D66-ABD1-4719-BD0B-1C7091C26581
// Assembly location: C:\Users\Chris\Desktop\ExCard.exe

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;

internal class \u200C‌⁮‎‫‍⁫‏⁯‏‍⁪‏⁪‬‮‬⁯⁫⁯​⁭‪⁯‮⁪⁯‍⁫⁮‫‏⁪⁫⁮⁪⁯⁮⁯‏‮<\u0001, \u0002> : IDictionary<\u0001, \u0002>, ICollection<KeyValuePair<\u0001, \u0002>>, IEnumerable<KeyValuePair<\u0001, \u0002>>, ICollection, IEnumerable, IDictionary, \u202D⁭‌⁬⁪⁪⁯‪⁫⁬⁫‮‍⁪‮​‬‌‏⁫⁪⁯⁪‍‎⁯‭⁮‬‍⁯‪‮​‬‫⁯‮​‪‮
{
  private readonly IDictionary \u200E‬⁫‏⁫⁪⁯‫⁯​‏⁭⁪‪‬‪⁫⁫‎⁯⁯⁫‬⁫‍‍⁪⁫‮​⁪⁬‫​‪​‎​‮‮;
  private readonly IDictionary<\u0001, \u0002> \u202B⁯⁪‌⁬⁯‏‌‪⁪‭⁯⁭‌‬‎‮‬‮‪‎​‫‬⁪⁮⁮‮‮​‮‬‎​‏‎‫‍‎‮‮;
  private readonly IReadOnlyDictionary<\u0001, \u0002> \u206B‭‮‫‎‮⁭‫‌‪⁮‬⁪‬‮‪‍‮‪‬‍‬​⁯‏⁮‏‮‍​⁮⁮‮‪⁭⁮⁪‏⁫⁯‮;
  private object \u200B⁫‮​⁫‌⁯⁯‎‎‭⁯⁯⁮⁭⁭⁭⁫⁭‮‏⁭‎‍⁪⁬⁫‪⁭‌​‍‫⁭‬⁪⁬‌⁫‬‮;

  public \u200C‌⁮‎‫‍⁫‏⁯‏‍⁪‏⁪‬‮‬⁯⁫⁯​⁭‪⁯‮⁪⁯‍⁫⁮‫‏⁪⁫⁮⁪⁯⁮⁯‏‮(IDictionary _param1)
  {
    // ISSUE: unable to decompile the method.
  }

  public \u200C‌⁮‎‫‍⁫‏⁯‏‍⁪‏⁪‬‮‬⁯⁫⁯​⁭‪⁯‮⁪⁯‍⁫⁮‫‏⁪⁫⁮⁪⁯⁮⁯‏‮(IDictionary<\u0001, \u0002> _param1)
  {
    // ISSUE: unable to decompile the method.
  }

  public \u200C‌⁮‎‫‍⁫‏⁯‏‍⁪‏⁪‬‮‬⁯⁫⁯​⁭‪⁯‮⁪⁯‍⁫⁮‫‏⁪⁫⁮⁪⁯⁮⁯‏‮(IReadOnlyDictionary<\u0001, \u0002> _param1)
  {
    // ISSUE: unable to decompile the method.
  }

  public void Add(\u0001 key, \u0002 value)
  {
    // ISSUE: unable to decompile the method.
  }

  public bool ContainsKey(\u0001 key)
  {
    // ISSUE: unable to decompile the method.
  }

  public ICollection<\u0001> \u206B⁭‪‌‏‎​⁪‫​⁯​⁫⁭‮​‏⁪‫⁪‎‭‭‍‍‌‬‫⁪⁪‍‌⁭‪‎‭‌⁯‏‍‮
  {
    get
    {
      // ISSUE: unable to decompile the method.
    }
  }

  public bool Remove(\u0001 key)
  {
    // ISSUE: unable to decompile the method.
  }

  public bool TryGetValue(\u0001 key, out \u0002 value)
  {
    // ISSUE: unable to decompile the method.
  }

  public ICollection<\u0002> \u202D⁮‌‍‌​​​‏‫⁯‍⁫⁭‎‪⁭‏⁮⁮‌⁪‮‏‏⁫⁬‏⁪⁯⁫⁭‎⁬‏⁬‫‬⁪‬‮
  {
    get
    {
      // ISSUE: unable to decompile the method.
    }
  }

  public \u0002 get_Item(\u0001 key)
  {
    // ISSUE: unable to decompile the method.
  }

  public void set_Item(\u0001 key, \u0002 value)
  {
    // ISSUE: unable to decompile the method.
  }

  public void Add(KeyValuePair<\u0001, \u0002> item)
  {
    // ISSUE: unable to decompile the method.
  }

  public void Clear()
  {
    // ISSUE: unable to decompile the method.
  }

  public bool Contains(KeyValuePair<\u0001, \u0002> item)
  {
    // ISSUE: unable to decompile the method.
  }

  public void CopyTo(KeyValuePair<\u0001, \u0002>[] array, int arrayIndex)
  {
    // ISSUE: unable to decompile the method.
  }

  public int \u206F‪‫‏‬‍​‬‮‌⁬‪⁫⁪⁪⁬‭‮⁯‬‬‎‏‮⁪⁫⁯‏⁫‫‪​‬⁯‫‭⁪‭‍⁪‮
  {
    get
    {
      // ISSUE: unable to decompile the method.
    }
  }

  public bool \u200F‏‫⁪‍⁮‌⁪‌‭⁭⁭⁫‌‮⁭⁮⁭⁪‮‬‮‮⁮⁭‫⁯‍‌‭‎‮‫⁭‏⁭‫‭‍‭‮
  {
    get
    {
      // ISSUE: unable to decompile the method.
    }
  }

  public bool Remove(KeyValuePair<\u0001, \u0002> item)
  {
    // ISSUE: unable to decompile the method.
  }

  public IEnumerator<KeyValuePair<\u0001, \u0002>> GetEnumerator()
  {
    // ISSUE: unable to decompile the method.
  }

  IEnumerator IEnumerable.GetEnumerator()
  {
    // ISSUE: unable to decompile the method.
  }

  void IDictionary.Add(object key, object value)
  {
    // ISSUE: unable to decompile the method.
  }

  object IDictionary.get_Item(object key)
  {
    // ISSUE: unable to decompile the method.
  }

  void IDictionary.set_Item(object key, object value)
  {
    // ISSUE: unable to decompile the method.
  }

  IDictionaryEnumerator IDictionary.GetEnumerator()
  {
    // ISSUE: unable to decompile the method.
  }

  bool IDictionary.Contains(object key)
  {
    // ISSUE: unable to decompile the method.
  }

  bool IDictionary.\u202C‮‮⁬‫‮⁬‫‌⁯‏⁪‍⁬​⁮​​‭⁮‮‌⁫‪‮‮‍‫‪⁬⁭​‏⁮‪⁯⁭‪‫‪‮
  {
    get
    {
      // ISSUE: unable to decompile the method.
    }
  }

  ICollection IDictionary.\u206F‭‫⁪‍⁭⁪‎​⁮‌⁬‎​‌‮‬‭​‏⁫⁮​‏⁮‍‍‮⁮​‌⁬‫⁯⁫⁯⁫‏‏‬‮
  {
    get
    {
      // ISSUE: unable to decompile the method.
    }
  }

  public void Remove(object key)
  {
    // ISSUE: unable to decompile the method.
  }

  ICollection IDictionary.\u206A‬‫‭‍‭⁮‌⁫⁭⁭‫‌‪⁬‌⁫‮‮⁮‎‬⁪⁯‏‮‫⁪‪​‭‏‌⁮⁯‎⁬‌​‮‮
  {
    get
    {
      // ISSUE: unable to decompile the method.
    }
  }

  void ICollection.CopyTo(Array array, int index)
  {
    // ISSUE: unable to decompile the method.
  }

  bool ICollection.\u202B⁯⁪⁭‮‏⁫⁯‮⁭​⁮‎‎⁮‎‎‎‪⁫‍‎​⁬⁪⁯⁭⁯‏‫‪⁬‪‭‪‍‫​‏⁯‮
  {
    get
    {
      // ISSUE: unable to decompile the method.
    }
  }

  object ICollection.\u202A⁪​⁭‎‬‬⁮‌‬‪⁮‭⁯⁯⁮⁫‭‌‌‏‬‬⁬‌⁮⁭‌‎‍​⁭⁪‎‍‌‪⁫⁮‫‮
  {
    get
    {
      // ISSUE: unable to decompile the method.
    }
  }

  public object \u200F⁭⁬⁯‏⁫‬‎⁭‏⁫‭‏⁪⁬‍⁬⁮⁫⁭⁫‪​‍‍‌​‌⁫⁮‏‌‍‬‬‏⁫‌‍‫‮
  {
    get
    {
      // ISSUE: unable to decompile the method.
    }
  }

  static void \u200F⁮⁪‭⁭⁪‪​‏​⁪‮‪⁪⁯‫⁭⁮‫⁪⁭‬⁪⁭⁯‬‬⁪‎⁪​⁬‫⁫⁪⁯⁬⁯⁮⁬‮([In] IDictionary obj0, [In] object obj1, [In] object obj2)
  {
    // ISSUE: unable to decompile the method.
  }

  static NotSupportedException \u202C⁪‭‬‎‫‭‍‭‭‍‍​⁮⁮‭⁫‏‏‬​‏‫⁫⁮‭⁫‮‮‎‬⁮⁮⁭⁪‭‫⁮​‫‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u200F‭⁫​‫‏‬‏⁫⁫⁪‮‬⁬⁫⁫‪‭⁫‏⁫‌⁮‎⁪‎‌‏⁬⁪‭‭‬⁪‌‍⁬‪‭⁫‮([In] IDictionary obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static ICollection \u202A⁮‮‫‌‏⁬‪‏‏⁭⁮​⁯⁯⁮⁪⁬⁯​‭‫‮‏‎⁫‫⁭‫⁪⁫‌⁮‫‬⁯⁬⁭‬‏‮([In] IDictionary obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206F‍⁮⁬⁫‎‭‎‌⁭⁭‮‪‌⁪‍‎‭‏⁬⁯⁮‍‍⁮‏‪⁪‏‍⁪⁭‏⁯⁪‮‌‮‪⁬‮([In] IDictionary obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static object \u202A‌⁫⁪‬​‏‮⁬⁫‪‍‍‭⁬⁪⁭⁫‪‪‭⁯⁮​⁪⁬‎​‪⁭⁬‫‍​⁪‎⁮⁮⁫‪‮([In] IDictionary obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static ICollection \u202A⁫⁬‬‬‮‎⁫‍⁭​‎⁪‎‪⁬‌⁫​⁪⁪⁬‏‬⁮​⁪​⁭⁬⁪⁮‍‬⁬⁭‌⁪⁭⁪‮([In] IDictionary obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200B‎⁯‌​‏⁫‎⁮⁯⁪‌‭‍⁭‏⁮⁫‌‪⁪​⁮‪‍⁯​⁬​⁫⁫‎⁯‍‬‪‬⁭‭⁬‮([In] IDictionary obj0, [In] object obj1, [In] object obj2)
  {
    // ISSUE: unable to decompile the method.
  }

  static int \u200C⁬‮‬⁫​⁮⁫‏⁭‮⁭‌‮‬⁮‮⁯⁯‎‬‮⁮⁮⁯‪⁭⁪⁮​‌‌‮⁯⁭‬‮⁮‮‍‮([In] IList obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200D‬‭⁮‌‍‭‭⁫‮⁭⁯‭⁯⁮‭⁫⁬‫⁬⁮‭⁯‪‏‭​‏⁫⁮‎⁭‏⁫‬‍⁯‪⁬‏‮([In] IDictionary obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u206A‌‬‍⁯⁯⁫​‏‬‎‏‭⁮​‪⁫‏⁯‎‏‫‭‏‬⁭⁬‪⁭‏⁫⁭​‭⁭‌⁯⁯‏⁪‮([In] IList obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static IDictionaryEnumerator \u200B‫‭‬‪⁬⁮⁪⁭‫‭‏‌‮⁮‮​‭‏‎⁭⁪​‏⁭‪⁬⁭⁭⁪‭⁯‫‫‮‫‫‪‮⁭‮([In] IDictionary obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static DictionaryEntry \u202C⁬‬‍⁮⁯‎‫⁪‭⁯⁭‫‏‎⁮⁪​⁫‮⁫​‎⁯‮‏⁭‫‏⁫‬⁯‌⁪‬‌‭‬‏⁪‮([In] IDictionaryEnumerator obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static int \u206E‪‫‍‭‍⁬⁬​‌‮⁪⁬‏⁭‬‮⁭‍‫‍‮‪‌‎‍‪‪‪⁬‏‫‫‫‬​⁬‎⁫‮([In] ICollection obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u206B⁯‏⁫‮‏⁭⁯​‫‌⁫‪‍⁬‮‌‭‍⁬⁫⁫‎⁭‮‏⁯‫‮⁪‫⁭‮‪‫‌‍⁪‭‏‮([In] IDictionary obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u206E⁮‏⁯‮‎⁮‪⁫⁭⁮​⁯‪⁪‏‌​‭‍⁪‌⁪‪‬⁭‎‪‬‫⁫⁪‍‫⁮‍‍⁬⁬‭‮([In] object obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u202D⁮‍‌⁬⁪‎‏⁯‏⁫⁬‬‫⁮‍‍​⁬⁬‫‪‏⁫‍⁪‏⁮‎‌‏⁪‎‍‬‬‪​‮‍‮([In] IDictionary obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206B⁯⁬‭​‭‬‌​⁭‬‭⁯‮‌‍⁬‌‭⁮⁬‮‫‏‌‪‍‍‬⁪‌⁪‎⁫‭‌‌‍‭‬‮([In] ICollection obj0, [In] Array obj1, [In] int obj2)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u200F‪‌‬‫⁭‌‭⁬⁮‍⁬⁫‫‬‍‎‫‫‭⁯​‬‪‮⁬‮⁬⁭‬⁪​⁯‏‍⁭‮‬​‍‮([In] ICollection obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static object \u202D⁪⁬⁪⁭‎‏‍‎⁭⁯⁬​‪‮⁪‍‎⁪⁪‭‎‫⁪‪‍‌‍‮⁪⁬‪‭‎​‏⁭‏‮‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static object \u200B‭‪‎‬‫‎‫‎‌‭⁪⁮‏⁪​‬‌⁪⁬‬‎⁬⁫⁮‏‬​‬⁭‭‪‮‎​⁭⁭‏⁫‮([In] ref object obj0, [In] object obj1, [In] object obj2)
  {
    // ISSUE: unable to decompile the method.
  }

  private struct \u200F‌‬⁬⁫‬⁮‮‍‌‌⁮​‬⁫‫‬⁭‫⁯⁯‮‎‫‍⁬‏⁮‭‬‍⁪⁫​‍⁯​⁯‍‮‮<\u0003, \u0004> : IEnumerator, IDictionaryEnumerator
  {
    private readonly IEnumerator<KeyValuePair<\u0003, \u0004>> \u202A‏‍⁫⁭⁬⁯⁯‫‍⁮‪⁯‮‍⁫⁭⁮‮⁬​⁬‭‮​‎‏‫⁫‏⁪‪‭‭‭‍⁪⁬‪⁬‮;

    public \u200F‌‬⁬⁫‬⁮‮‍‌‌⁮​‬⁫‫‬⁭‫⁯⁯‮‎‫‍⁬‏⁮‭‬‍⁪⁫​‍⁯​⁯‍‮‮(IEnumerator<KeyValuePair<\u0003, \u0004>> _param1)
    {
      // ISSUE: unable to decompile the method.
    }

    public DictionaryEntry \u202E⁪‮‎‬‪⁯‍‌⁪‌⁭‮‬⁭‫‬‪‍‭⁮‪⁭‍‍‫‬‪‌‮‌⁭⁭⁭⁫⁪‌‏⁪⁭‮
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public object \u200E⁬⁯‭‪‫⁭⁫‫⁪‌⁮‬⁪⁯‫‭⁫⁬‪‫‏⁬‎‎⁫⁭⁭⁭⁪‬‪‏⁭‭​⁫⁫‫‮
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public object \u200B‬⁭⁪‏‫‫‬⁫⁬⁭‭⁬‮‎‎‎‫‎‭‎‪⁬‪‮⁫‮‎‏‏‬⁮⁬⁭⁫‎⁬⁭‮‏‮
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public object \u206E‬⁯⁯⁫‬⁭‪⁭‬‮‏​⁯⁫‬⁪‪‬⁪⁬‬‬‍‫‭​⁯‍​‍‮‮‬⁮⁮⁯⁬‮‭‮
    {
      get
      {
        // ISSUE: unable to decompile the method.
      }
    }

    public bool MoveNext()
    {
      // ISSUE: unable to decompile the method.
    }

    public void Reset()
    {
      // ISSUE: unable to decompile the method.
    }

    static bool \u200B‏‮‌‪‭‬‬⁪​⁮⁪‬‌‫‌⁯‍⁯‭‫⁭⁬‏⁭​‫‬​⁮⁬​‍‫⁯‭‬‪‍⁮‮([In] IEnumerator obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    static void \u206A⁯⁯​⁯‮‭⁭‎‮⁬‏‍‍‍⁪‫‍‌‫‮‫‫‮‌⁯‫⁯‪⁮‍‍‍⁯‭⁫‭‮‫‭‮([In] IEnumerator obj0)
    {
      // ISSUE: unable to decompile the method.
    }
  }
}
