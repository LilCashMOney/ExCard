// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: ExCard, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D8B94D66-ABD1-4719-BD0B-1C7091C26581
// Assembly location: C:\Users\Chris\Desktop\ExCard.exe

using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading;

internal class \u003CModule\u003E
{
  internal static byte[] \u200C​⁯‎‬‫‌⁫⁪‎⁯⁬⁬‮‬‌‍‏‌‬⁯‮⁭‪‭⁯⁫‮‌‮⁮‏⁬‏‬‌‎‪‪‪‮;
  internal static \u003CModule\u003E.\u200F‎‬‮⁪‎​‌‏‪⁫‫‭‫‬⁫‭⁭‭‍⁫⁮‍‏‬⁬⁮⁪‫‍⁭‏‍‍‪⁫⁯‍​‮‮ \u206C‬‬‌​‌⁯‏‏‎‮‏‬‏‎‎⁪⁪‍‪‏⁬‍⁯‏‭‪‬‌⁫​⁬‬⁬⁮⁬⁪‎‫‍‮;
  internal static Assembly \u202A⁭‎‪⁪‮​⁬‫⁪⁮‬‬‌‮‌‫‌‬‏‏⁭⁪⁬‎​‭‮‬⁭⁭‏‮‍​‌⁭‮‌‎‮;
  internal static \u003CModule\u003E.\u202E​⁮⁭⁭​‫⁭‫⁫‍‮‏‍‌‫‪‪⁯‬‭‏‮⁬​‫‭‌⁪‪‍⁫⁬⁯‪‎⁮‌‍‮ \u200C​‪⁮⁮‎‮‪⁭⁬⁭‍⁭‭‮⁬‫‫⁮⁪‬‮‌‏⁫‍‪⁯⁭‭​​⁪⁯‮‪‍‍‭‍‮;

  static \u003CModule\u003E()
  {
    \u003CModule\u003E.\u200F‍‮‎‪⁬​⁪‏‮‎‌‪‭⁫‎‬‌​⁮‫‏‌‎‪‭‪‫‌‪‮‌‫‮‍‭⁯⁭‎⁪‮();
    \u003CModule\u003E.\u206D‭​‭⁬‍⁭‬‏‏‍‏⁫‎‏‍‏‫⁭‮‪‫⁮‮‪⁬‍‎⁭‭⁬⁪‬⁭⁯‬‪⁭‍⁮‮();
label_1:
    int num1 = -1577627335;
    while (true)
    {
      int num2 = -6569066;
      uint num3;
      switch ((num3 = (uint) (num1 ^ num2)) % 3U)
      {
        case 0:
          goto label_1;
        case 1:
          \u003CModule\u003E.\u206D⁭‍‏⁬⁬⁬⁮‮‎‌​‏⁪‍‮‫⁯⁯⁬⁯‎⁮‍‫‌‭‏⁫‌‭⁯⁬‎‎‎‭‌‬‫‮();
          num1 = (int) num3 * -1753296118 ^ 1436130721;
          continue;
        default:
          goto label_4;
      }
    }
label_4:
    \u003CModule\u003E.\u202A⁬⁮‍⁬⁫⁪‎‭⁪⁪‎‏‬‌‬‍​⁭⁯⁪​⁫‏‭‍‍⁯‍⁬⁪⁯⁬⁮‭⁪⁫⁬⁯‫‮();
    \u003CModule\u003E.\u202C⁮‏‍‭‭‮‏‪‮⁬⁬⁭‫‪⁬⁪‌‍⁬‬‫⁫‬‫⁫‬​‌⁬​⁫‎‎‍‏​‪⁫‫‮();
  }

  private static void \u202C⁮‏‍‭‭‮‏‪‮⁬⁬⁭‫‪⁬⁪‌‍⁬‬‫⁫‬‫⁫‬​‌⁬​⁫‎‎‍‏​‪⁫‫‮()
  {
    // ISSUE: unable to decompile the method.
  }

  private static void \u200E‪‮‪‭‎⁪‎⁫‌⁯⁪‮‏⁫⁪‮‪‭‮⁭⁮‭‮⁭‮⁭⁫⁮⁯⁯‏‮‍‭‮​‪‏‪‮([In] object obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect")]
  internal static extern unsafe bool \u200D‫‎‌​‌‬⁯⁪‏‪⁬‎⁯‮‎⁭‌‬⁯⁮⁬‬⁮⁮‏‮⁫‭⁪​‍⁫‮⁮‏‮⁪⁮‬‮([In] byte* obj0, [In] int obj1, [In] uint obj2, [In] ref uint obj3);

  internal static void \u202A⁬⁮‍⁬⁫⁪‎‭⁪⁪‎‏‬‌‬‍​⁭⁯⁪​⁫‏‭‍‍⁯‍⁬⁪⁯⁬⁮‭⁪⁫⁬⁯‫‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static Type \u200C‌⁭‪‭‬​⁯‍⁬⁭‪⁪⁪⁮‍‌‪⁫⁮‌​⁫⁪⁯​‭⁬⁮⁫⁬‫⁬⁭‮‌‮‎‏‮‮([In] RuntimeTypeHandle obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Type \u200D‌‍⁯‏‎‍‎⁯⁯⁯⁪‪⁭⁫⁪‎⁭‌⁪​‏⁫‪‍⁯⁫‫⁬​⁫‬‫‌⁫‫‬​‭⁭‮([In] RuntimeTypeHandle obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static MethodInfo \u200D⁮‮​‮⁯‌‏‮​‬⁮⁫‍​‫‎‏⁭‬‍‪‭⁬‍‭⁯‭‌​⁭‌‫⁮⁭⁮‍⁭‭‏‮([In] Type obj0, [In] string obj1, [In] Type[] obj2)
  {
    // ISSUE: unable to decompile the method.
  }

  static string \u202C‎⁬‮‍⁫⁪‫‪‍⁯⁭‮⁯‫⁫⁭‭‏‮⁮‎‮⁫‬‎‏⁪⁬‮⁫‏⁯‬‍‫⁬⁪⁬‎‮([In] string obj0, [In] string obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static object \u202B‍⁭‏⁭⁫‍‪‏‏‬‮⁫⁬‍​‎⁫⁯‌‍‮⁮‏‫⁯‏‍‏‌⁬⁪‮‫‪​⁪⁫⁪⁬‮([In] MethodBase obj0, [In] object obj1, [In] object[] obj2)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u206A‍⁬‪‭⁯‌⁭‌‌‍‎⁭‭⁪‮‏‪​‭⁭‌‫⁬⁭‍‮​‍⁭⁫‭‪⁬⁮‭‬‏⁪⁬‮([In] object obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206E​‫‎‎‍⁯⁭⁬⁬⁭​‍‫‬⁫‫‎‪⁯⁫‮‭⁯‮‪⁬⁫⁭⁯‮‬‬⁪⁫⁮​‮‭⁬‮([In] string obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Thread \u200B⁫‭⁭⁯‫⁪⁮‍‪‌‌⁮​⁪‪‭⁫‏‏‍‮‏‫‏⁬‎⁯‌‏⁯⁬‪‍‪‍‌⁪‭⁮‮([In] ParameterizedThreadStart obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206E‏⁫⁮‫⁬⁪‬‎‌⁪⁭‮‮⁪⁫‍‌‪​⁪‎‫‫​‭‭‪⁯⁮‮‪‎⁪⁭⁯​‫‮⁭‮([In] Thread obj0, [In] bool obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206E⁫⁫‏‫‮‫⁫​‍⁮‮⁪‮‭⁭⁬‏⁬‪⁬‌‫⁭⁯⁭⁫‭‎‎⁫‬⁪⁬‎⁮⁯‭‌⁭‮([In] Thread obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static Thread \u206D‏‬‏⁬‪⁮‫⁬‎‫⁯⁪‬‏‎⁭‌⁮‎⁫‬‬⁭‎⁯‪⁪⁯⁭‏‭⁬‬⁯‪‫‫‎‎‮([In] ParameterizedThreadStart obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200F‌‏‭‭⁯‌‌⁯‌‎‏⁯​⁯⁬‎⁭‫⁭​⁭⁭​⁮‍‍‪‫⁬‫‍‪⁫‫‍⁯⁬‎⁯‮([In] Thread obj0, [In] bool obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static Thread \u206A‪‎‮‮‎⁪⁬‫‫⁮‪‮⁯‬⁯‭‎⁯‪​⁬‫⁪‎‫‫‎‏⁯‬‪⁭⁬​⁮⁬‍‍‍‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200B‬​⁭‌‌⁫⁪‬‪​‪‬‪‫⁭‭‭‎‏⁪‎‭‏‫​⁪⁮⁬‫‪‏⁬⁪‍‏​‭‬‌‮([In] Thread obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206F⁪⁪‭‎‌‭⁮​‫‪‭⁯‪‫‍⁭⁯‏⁮‮‌⁪‬⁪​⁪‮‪‍⁮‪​‮⁭‎‏‏⁯⁭‮([In] int obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u200C⁬‬​​‍⁫⁪​‌​‍⁪‬⁬‭‏‌⁬⁬‮​⁮‬⁭​‍⁯‪‍⁯⁭‭‎‏‭⁭​⁫⁬‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u206B‫‎‎⁮‫‪‌‫⁭‎‫⁯‍‮⁪‭‪‬⁫​⁬​⁫‮⁫⁭⁫⁫⁪‎‍‬‬‏⁯‌‪‍‮‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200C⁯‌‏‎‌‮⁭⁮‪‪⁭⁭‏⁭‌‪​‎‭⁭⁯⁮‭‏‮‪‬⁫‍‍⁯‪‬‎⁪‬‬⁯⁯‮([In] string obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u206A‭⁫‏‪⁭‎⁬‏⁯‌⁪‬⁯⁭​⁪‏‍‭‏‌⁭⁬⁪​⁮‏‍‎⁬⁯⁯‭⁯‎‍‍‫‬‮([In] Thread obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200F‭‎‭⁪‭‬⁯‫‭‬‭‎⁫‮‪⁪⁫⁫‏⁯⁭‍⁫‮⁫‫⁫‏‌⁬⁮⁭‮⁯⁭​⁯‭‮‮([In] string obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206B⁮‎‭‪‬‪‍‫⁪⁬⁬‭‏‪⁭⁬‪‏⁭⁫‍‭⁮‭‌⁯‮‫‮‌‫⁪⁬‌⁭‮‏‬⁪‮([In] int obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Type \u200F⁭⁫​⁪‎⁭⁫‫‫⁯‬⁫​‎⁯‫‭‭‬‎⁯⁬⁪‪‪‏​​‬‫⁭⁯‪⁭‎⁬⁬‪⁭‮([In] RuntimeTypeHandle obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Module \u200F‬‭‮‍‫‍‬‌‭⁭‌‬‭⁯‮⁪‎‎‪⁭‍‫‮‬‭‍‬⁭⁫⁭‌⁮⁭⁬⁯‍⁭‬‎‮([In] Type obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static IntPtr \u200F‏⁯‭⁭‫‫‪‍‎‭‌⁭‮⁯⁯‌⁮‎‭‫‏‫⁪‌‮‫​‪‮⁯‍⁪⁫⁪‬‭‪‭‮‮([In] Module obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static string \u202A‍‏⁮‬‪‎‏‬‎⁯‌⁬‏⁬⁪‪‭‭⁭‬‌‌⁫‬⁬⁪‭⁪‎​‍⁬⁪​⁭‌‪‪‌‮([In] Module obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static char \u200B⁫⁪‍‪⁫⁪⁬⁭⁫​‌‍‎‎‬​‍‎‎‫‍‮⁪‭⁭⁮‎‪‍⁪‎‏‫⁬​‭​⁭⁪‮([In] string obj0, [In] int obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u202C⁯⁯⁫⁬‫⁪‮‍‮⁬‍‪‪‫‎⁭‫​​​‮⁪‫⁬⁪‎⁮‫‪‍​⁫‎‍‌⁮⁭‌‫‮([In] byte[] obj0, [In] int obj1, [In] IntPtr obj2, [In] int obj3)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206C‬‏‬‌⁯⁮‬‫‮‬‎‫⁫‌⁬‮​⁮‌​‎⁬⁮‮⁫‍​​‏⁬‫‬‎⁮‌⁪‎‮⁮‮([In] byte[] obj0, [In] int obj1, [In] IntPtr obj2, [In] int obj3)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static byte[] \u200C‫‍​​⁫‍‬‏‏​⁯‏⁪⁮‎‬⁪⁪‍‪‪‬⁭‭‍‏‭⁫‫⁬‮‭‮‫‪‬‭‍⁬‮([In] byte[] obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static void \u206D⁭‍‏⁬⁬⁬⁮‮‎‌​‏⁪‍‮‫⁯⁯⁬⁯‎⁮‍‫‌‭‏⁫‌‭⁯⁬‎‎‎‭‌‬‫‮()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u206B⁪‬​⁪‮⁪‬⁯​‎‎‭‎‌⁬⁭‬‍⁪⁭‍⁫⁬⁫⁭⁮⁬‭‌‫⁬⁬‭‌⁪‮‬⁪‌‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u200F⁭⁮⁮‎​⁮⁭‬‎‫‏‮⁯⁫‬⁪⁬‬‏⁪‌‭‍⁪⁭⁯‍‪‌⁬⁫​⁮‌‫‌⁮‮⁭‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u206E‪‫⁭‫‍⁪‬‮‎⁭‌⁭‫⁬⁬‎⁮‍‫⁭‌‍‍⁫⁫⁬⁬‮⁮‮​‌⁪⁬​‮​⁫‌‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u206A‍‌⁯​‫‍⁭‍⁭⁪‭⁫‎⁯‭‍‮⁭‎‭‎⁪⁪⁪‮‎‌⁫‬‎⁫⁭‪⁬⁫‪‍‌‮‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u202A‎⁯‎‏‎⁭‬‭​​​‎‬‎⁮‎⁬⁫⁬‭​‮‏‪⁮⁬‎‏‍‬⁭‍‍‌⁫⁬‪⁪⁮‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static void \u206D‭​‭⁬‍⁭‬‏‏‍‏⁫‎‏‍‏‫⁭‮‪‫⁮‮‪⁬‍‎⁭‭⁬⁪‬⁭⁯‬‪⁭‍⁮‮()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static Assembly \u200C​‭‫⁯⁪‭⁫‎⁬‭‫⁬‌‮‌⁯‭⁭‌‫‎‬‍‎‏‍‫‌​‮‍⁫⁫‍⁯‎⁮⁯⁮‮([In] object obj0, [In] ResolveEventArgs obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect")]
  internal static extern bool \u200C‌‌‭‍⁭⁬⁬‎⁬⁬⁪⁯⁮⁭⁪‍⁪‮⁫⁪‮​‮‪⁯⁬‮⁪‏⁪‪⁮‫⁮‫‎‪⁪⁯‮([In] IntPtr obj0, [In] uint obj1, [In] uint obj2, [In] ref uint obj3);

  internal static unsafe void \u200F‍‮‎‪⁬​⁪‏‮‎‌‪‭⁫‎‬‌​⁮‫‏‌‎‪‭‪‫‌‪‮‌‫‮‍‭⁯⁭‎⁪‮()
  {
    Module module = typeof (\u003CModule\u003E).Module;
label_1:
    int num1 = 1090212110;
    while (true)
    {
      int num2 = 505534384;
      uint num3;
      uint num4;
      uint num5;
      uint[] numArray1;
      uint[] numArray2;
      uint num6;
      uint num7;
      uint num8;
      uint num9;
      uint num10;
      uint* numPtr1;
      uint num11;
      uint num12;
      byte* numPtr2;
      ushort num13;
      int index;
      int num14;
      uint* numPtr3;
      uint num15;
      ushort num16;
      uint num17;
      uint num18;
      uint* numPtr4;
      byte* hinstance;
      bool flag;
      string fullyQualifiedName;
      int num19;
      int num20;
      switch ((num3 = (uint) (num1 ^ num2)) % 63U)
      {
        case 0:
          num1 = (int) num3 * 594943649 ^ 1958555974;
          continue;
        case 1:
          goto label_23;
        case 2:
          \u003CModule\u003E.\u200C‌‌‭‍⁭⁬⁬‎⁬⁬⁪⁯⁮⁭⁪‍⁪‮⁫⁪‮​‮‪⁯⁬‮⁪‏⁪‪⁮‫⁮‫‎‪⁪⁯‮((IntPtr) ((void*) numPtr3), num5 << 2, num6, ref num6);
          num1 = (int) num3 * 1902029483 ^ -1033331224;
          continue;
        case 3:
          if (fullyQualifiedName.Length > 0)
          {
            num1 = (int) num3 * -999657353 ^ 1847720330;
            continue;
          }
          num19 = 0;
          goto label_66;
        case 4:
          int num21 = (int) num6 == 64 ? -1269823595 : (num21 = -283911651);
          num1 = num21 ^ (int) num3 * -601334745;
          continue;
        case 5:
          num1 = (int) num3 * 2026654972 ^ 947657777;
          continue;
        case 6:
          numArray1[13] = numArray1[13] * numArray2[13];
          num1 = (int) num3 * 1313524722 ^ -1136037718;
          continue;
        case 7:
          goto label_1;
        case 8:
          numArray1[10] = numArray1[10] * numArray2[10];
          num1 = (int) num3 * -1128705187 ^ 1014299418;
          continue;
        case 9:
          int num22;
          num1 = num22 = num14 >= (int) num13 ? 1616772067 : (num22 = 1271951415);
          continue;
        case 10:
          uint* numPtr5 = numPtr3;
          int num23 = (int) *numPtr5 ^ (int) numArray1[(IntPtr) (num15 & 15U)];
          *numPtr5 = (uint) num23;
          numArray1[(IntPtr) (num15 & 15U)] = (uint) (((int) numArray1[(IntPtr) (num15 & 15U)] ^ (int) *numPtr3++) + 1035675673);
          num1 = 992508095;
          continue;
        case 11:
          numArray1[9] = numArray1[9] ^ numArray2[9];
          num1 = (int) num3 * 273829790 ^ 973187146;
          continue;
        case 12:
          num7 = num12 >> 11 | num12 << 21;
          num1 = (int) num3 * -2028775628 ^ -354845993;
          continue;
        case 13:
          numPtr3 = (uint*) (hinstance + (flag ? (int) numPtr1[3] : (int) numPtr1[1]));
          if (flag)
          {
            num20 = (int) numPtr1[2];
            break;
          }
          num1 = 1429478087;
          continue;
        case 14:
          ++num15;
          ++num4;
          num1 = (int) num3 * -127084579 ^ 1886220481;
          continue;
        case 15:
          numArray1[index] = num7;
          num1 = 630799227;
          continue;
        case 16:
          num4 = 0U;
          num1 = (int) num3 * -1458079405 ^ -1241762872;
          continue;
        case 17:
          num15 = 0U;
          num1 = 893822068;
          continue;
        case 18:
          numArray1[1] = numArray1[1] * numArray2[1];
          numArray1[2] = numArray1[2] + numArray2[2];
          num1 = (int) num3 * 823274446 ^ 1072106365;
          continue;
        case 19:
          uint* numPtr6 = numPtr1;
          IntPtr num24 = new IntPtr(4);
          uint* numPtr7 = (uint*) ((IntPtr) numPtr6 + num24);
          int num25 = (int) *numPtr6;
          uint* numPtr8 = numPtr7;
          IntPtr num26 = new IntPtr(4);
          numPtr1 = (uint*) ((IntPtr) numPtr8 + num26);
          int num27 = (int) *numPtr8;
          num18 = (uint) (num25 * num27);
          int num28;
          num1 = num28 = (int) num18 != 1278384362 ? 58114005 : (num28 = 919130545);
          continue;
        case 20:
          numArray1[8] = numArray1[8] + numArray2[8];
          num1 = (int) num3 * 1828036268 ^ -2000073483;
          continue;
        case 21:
          num11 = numPtr1[2] >> 2;
          num1 = (int) num3 * 333909831 ^ -1851908132;
          continue;
        case 22:
          num8 = num17 >> 3 | num17 << 29;
          num1 = (int) num3 * 728781068 ^ 2067260587;
          continue;
        case 23:
          numArray1[14] = numArray1[14] + numArray2[14];
          num1 = (int) num3 * 55299579 ^ -1261331412;
          continue;
        case 24:
          fullyQualifiedName = module.FullyQualifiedName;
          num1 = (int) num3 * -1381809004 ^ 1022883185;
          continue;
        case 25:
          numPtr1 += 8;
          ++num14;
          num1 = 1330416612;
          continue;
        case 26:
          num7 = 1760772697U;
          num14 = 0;
          num1 = (int) num3 * -291587350 ^ 201546285;
          continue;
        case 27:
          num20 = (int) *numPtr1;
          break;
        case 28:
          index = 0;
          num1 = (int) num3 * -892675415 ^ 1107764725;
          continue;
        case 29:
          num9 = (uint) (((int) num12 ^ (int) *numPtr4++) + (int) num8 + (int) num17 * (int) num7);
          num1 = 205676943;
          continue;
        case 30:
          numArray1[5] = numArray1[5] + numArray2[5];
          numArray1[6] = numArray1[6] ^ numArray2[6];
          num1 = (int) num3 * -1754669110 ^ 89335207;
          continue;
        case 31:
          num8 = 1678142476U;
          num17 = 4087916292U;
          num1 = (int) num3 * -1021043675 ^ 1427701919;
          continue;
        case 32:
          numPtr3 = (uint*) null;
          num5 = 0U;
          numPtr1 = (uint*) (numPtr2 + 24 + (int) num16);
          num1 = (int) num3 * 1095893174 ^ -2064231717;
          continue;
        case 33:
          num1 = (int) num3 * 1705734108 ^ -525164167;
          continue;
        case 34:
          num12 = 4266178095U;
          num1 = (int) num3 * 563676186 ^ -117694370;
          continue;
        case 35:
          numPtr4 = (uint*) (hinstance + (flag ? (int) numPtr1[3] : (int) numPtr1[1]));
          num1 = 1002272066;
          continue;
        case 36:
          int num29;
          num1 = num29 = num4 < num5 ? 1722091181 : (num29 = 1920619167);
          continue;
        case 37:
          num19 = (int) fullyQualifiedName[0] == 60 ? 1 : 0;
          goto label_66;
        case 38:
          numArray1 = new uint[16];
          num1 = (int) num3 * -2064364638 ^ 248732412;
          continue;
        case 39:
          numArray1[11] = numArray1[11] + numArray2[11];
          numArray1[12] = numArray1[12] ^ numArray2[12];
          num1 = (int) num3 * -2127337099 ^ -1933316333;
          continue;
        case 40:
          num10 = 0U;
          num1 = (int) num3 * 524857900 ^ 1570412792;
          continue;
        case 41:
          ++index;
          num1 = (int) num3 * -2028135989 ^ -689296124;
          continue;
        case 42:
          num8 = num17;
          num1 = (int) num3 * -823658107 ^ -1806968074;
          continue;
        case 43:
          num6 = 64U;
          num1 = (int) num3 * 894815804 ^ 1846629243;
          continue;
        case 44:
          num12 = num8 >> 5 | num8 << 27;
          num1 = (int) num3 * -552578175 ^ 1046457941;
          continue;
        case 45:
          numArray1[7] = numArray1[7] * numArray2[7];
          num1 = (int) num3 * -974032369 ^ -1856511950;
          continue;
        case 46:
          numArray1[0] = numArray1[0] ^ numArray2[0];
          num1 = (int) num3 * 1541294063 ^ -482625989;
          continue;
        case 47:
          num1 = (int) num3 * -1057842998 ^ -113556870;
          continue;
        case 48:
          int num30;
          num1 = num30 = (int) num18 != 0 ? 1315106816 : (num30 = 2028019132);
          continue;
        case 49:
          int num31;
          num1 = num31 = index < 16 ? 716750275 : (num31 = 2052571911);
          continue;
        case 50:
          num17 = num7 >> 7 | num7 << 25;
          num1 = (int) num3 * 2038380844 ^ 955118522;
          continue;
        case 51:
          hinstance = (byte*) (void*) Marshal.GetHINSTANCE(module);
          numPtr2 = hinstance + (int) *(uint*) (hinstance + 60);
          num1 = (int) num3 * -299597433 ^ -265310236;
          continue;
        case 52:
          goto label_3;
        case 53:
          numArray1[15] = numArray1[15] ^ numArray2[15];
          num1 = (int) num3 * -1229867929 ^ 1741226882;
          continue;
        case 54:
          num16 = *(ushort*) (numPtr2 + 20);
          num1 = (int) num3 * -1293163779 ^ -1871219313;
          continue;
        case 55:
          numArray2[index] = num8;
          num1 = (int) num3 * 1991651116 ^ 1710580972;
          continue;
        case 56:
          numArray1[4] = numArray1[4] * numArray2[4];
          num1 = (int) num3 * -1662736782 ^ 1823740273;
          continue;
        case 57:
          numArray2 = new uint[16];
          num1 = (int) num3 * -1597153401 ^ -56728459;
          continue;
        case 58:
          num13 = *(ushort*) (numPtr2 + 6);
          num1 = (int) num3 * -1337976030 ^ -839927002;
          continue;
        case 59:
          int num32;
          num1 = num32 = num10 >= num11 ? 2028019132 : (num32 = 2104270942);
          continue;
        case 60:
          numArray1[3] = numArray1[3] ^ numArray2[3];
          num1 = (int) num3 * -1384431097 ^ 1760462195;
          continue;
        case 61:
          num8 = num7;
          num7 = num9;
          ++num10;
          num1 = (int) num3 * -299380096 ^ 118458481;
          continue;
        case 62:
          num12 = num8;
          num1 = (int) num3 * 1464219937 ^ -536906544;
          continue;
        default:
          goto label_71;
      }
      int num33 = 2;
      num5 = (uint) num20 >> num33;
      num1 = 2028019132;
      continue;
label_66:
      flag = num19 != 0;
      num1 = 1033409160;
    }
label_71:
    return;
label_3:
    return;
label_23:;
  }

  internal struct \u206B⁯⁭⁭​‫‍‪‮⁮‌⁮‍‎‍⁯⁯‬⁬⁪‍⁮⁪‫‌‫‪‮⁮‍⁪‎‏⁮‫​‫‭​‫‮
  {
    internal uint \u200D⁬⁮⁫⁪‬‫​‎‮‌‪‎‫‎‌‏‏‌‏‮‎⁮‏​‭‌⁬‮‫‭‍⁮​‭‫‌⁯⁫⁮‮;

    internal void \u202E‍‮‍‌‍⁮‬‬‮‪‪⁮⁮‭‎‏‬⁮​⁮⁪‭‌‌‏‫⁫⁯‬​‮‌‍⁪‌⁪⁫‍‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u202B‮⁬‬⁭⁭⁭‍‫‬⁯‮​‭‏⁯‍‍‪‮‍⁭‌‬‏‌⁭​‪⁪‭⁬‪‍‏‭‪⁪‏‍‮([In] \u003CModule\u003E.\u202C‬‬‎⁯⁯‌‍‏⁭⁮‮⁯⁯⁫‌‌‬⁯⁫​⁮‏⁬⁫‍⁬‪‎‌‍‏‬‬⁯‪⁬⁬‬⁭‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal struct \u202D‌⁪⁫⁭‌‫⁮‎⁮‍‮⁯‬‫‭⁯‍⁮⁫‭⁯‌⁯⁭⁬‎‭⁮‪⁯⁬⁮⁪‏⁯⁮⁯⁫‌‮
  {
    internal readonly \u003CModule\u003E.\u206B⁯⁭⁭​‫‍‪‮⁮‌⁮‍‎‍⁯⁯‬⁬⁪‍⁮⁪‫‌‫‪‮⁮‍⁪‎‏⁮‫​‫‭​‫‮[] \u200E‫⁮‍‬⁬‪​‭‭‏‏​‫‪‭‍‏⁬‌‎‮⁬‌‬‭‮⁮⁭⁭‌⁯‎⁯⁮‬‍‮⁮⁮‮;
    internal readonly int \u202D⁫⁪‫‮‭‌‬⁮‌⁬‎⁬⁭‎‌⁭‮⁭‏‌⁪⁭⁬‪‫‍⁮‍⁪⁬‮⁪⁭‬‭‫‌‫⁭‮;

    internal \u202D‌⁪⁫⁭‌‫⁮‎⁮‍‮⁯‬‫‭⁯‍⁮⁫‭⁯‌⁯⁭⁬‎‭⁮‪⁯⁬⁮⁪‏⁯⁮⁯⁫‌‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202D‭⁫‬‏⁬⁭‫‪‫​​‌‮⁯‭‫‎‪‬‬‬‮​‪​⁯⁮‏‍‮⁭‏⁪‎⁫‌⁯‭‎‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u202C⁭⁮‪​⁫⁬⁯⁪⁯⁮⁮‬⁭⁬‮​‍​⁭‌​‮⁪⁪⁪‍⁭‮‭‫‍‫⁯⁫​‪⁪‮⁮‮([In] \u003CModule\u003E.\u202C‬‬‎⁯⁯‌‍‏⁭⁮‮⁯⁯⁫‌‌‬⁯⁫​⁮‏⁬⁫‍⁬‪‎‌‍‏‬‬⁯‪⁬⁬‬⁭‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u202C‬‏‫‍‌‭‍‪‬⁪⁬⁯⁪⁭‮‏‍‏‌‎‫‍‌‭‬‫​‮‌⁪​​‫⁫⁭‫⁪⁯⁭‮([In] \u003CModule\u003E.\u202C‬‬‎⁯⁯‌‍‏⁭⁮‮⁯⁯⁫‌‌‬⁯⁫​⁮‏⁬⁫‍⁬‪‎‌‍‏‬‬⁯‪⁬⁬‬⁭‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static uint \u206B‎‎⁯⁮‍‎‬⁮⁮‍‏‭⁫‌‏⁫‏‍⁯‍‭‭⁮⁭‍‍‮‪‍‫‪⁬⁮​‏⁫⁯‍⁮‮([In] \u003CModule\u003E.\u206B⁯⁭⁭​‫‍‪‮⁮‌⁮‍‎‍⁯⁯‬⁬⁪‍⁮⁪‫‌‫‪‮⁮‍⁪‎‏⁮‫​‫‭​‫‮[] obj0, [In] uint obj1, [In] \u003CModule\u003E.\u202C‬‬‎⁯⁯‌‍‏⁭⁮‮⁯⁯⁫‌‌‬⁯⁫​⁮‏⁬⁫‍⁬‪‎‌‍‏‬‬⁯‪⁬⁬‬⁭‮ obj2, [In] int obj3)
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal class \u202C‬‬‎⁯⁯‌‍‏⁭⁮‮⁯⁯⁫‌‌‬⁯⁫​⁮‏⁬⁫‍⁬‪‎‌‍‏‬‬⁯‪⁬⁬‬⁭‮
  {
    internal uint \u200F⁮‌‬⁮‎‪​⁬​⁬‮‭‮‏‌‏‮‏⁮‪‮‪‪‮‬⁬‏⁫‪‬‮‍​‭⁬⁪⁫‪‬‮;
    internal uint \u200B‬⁬⁬⁫‌‪‬‭⁫⁮⁫‮⁮‎‭‭‮‎‍‎‪⁯‫​⁯⁪⁬‬‫‫⁮⁪‬⁪‏⁯‬‮‮‮;
    internal Stream \u202C⁮‎⁮‬‏‭‭‍⁫​⁮‭⁭‍‭‬⁪‎⁬‏‌​‍‪‌⁪‌‫‍‏⁭⁫‌⁬⁫‭⁪‮⁫‮;

    internal void \u206C‮⁯‫‭‎⁮‏⁭​‍‬‍⁯‌⁯⁬⁭⁮‬‫‭⁬⁯⁪⁫⁫‮‫‌⁮⁪⁮​⁮‎​‪‌‬‮([In] Stream obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200D‏‮‬⁮⁮⁪‎‎​‌⁮‪‫‪​⁮‪⁯⁬⁪‬⁭​‍‭‎‌‌‎‭‎⁬‎‭‪‍⁬⁯‏‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202E⁭‭‮‪‭⁯⁯⁭‪⁫‏⁫⁮‭⁬‌‭⁪‭​‭‭⁬⁯⁪⁪⁫⁭‫⁭‍⁪‮⁯‍‏⁫‎⁮‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u206D‪⁯​⁮‫‎⁮‍⁬⁫⁯‎‮‮‌⁫⁯‏⁭⁫‎‭⁪‪‬‍‏⁪‎‫‏​‫‫⁬‮‮‍‌‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal \u202C‬‬‎⁯⁯‌‍‏⁭⁮‮⁯⁯⁫‌‌‬⁯⁫​⁮‏⁬⁫‍⁬‪‎‌‍‏‬‬⁯‪⁬⁬‬⁭‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal class \u200B⁯​⁬‫‬‫⁮​​‌⁬⁮⁪‪‪‎‎⁮‎⁪‌⁭⁭‎‪‏‍⁮‏‌‫⁭⁭‮‍⁪‏⁫‫‮
  {
    internal readonly \u003CModule\u003E.\u206B⁯⁭⁭​‫‍‪‮⁮‌⁮‍‎‍⁯⁯‬⁬⁪‍⁮⁪‫‌‫‪‮⁮‍⁪‎‏⁮‫​‫‭​‫‮[] \u200D‎‍⁬‭‏‌⁬‫​‪‍⁭⁫‮⁫‭⁪‏⁪⁫⁭‮​⁮⁭⁮​⁫⁬‫‬‏‏‌‌⁪‭⁭‭‮;
    internal readonly \u003CModule\u003E.\u206B⁯⁭⁭​‫‍‪‮⁮‌⁮‍‎‍⁯⁯‬⁬⁪‍⁮⁪‫‌‫‪‮⁮‍⁪‎‏⁮‫​‫‭​‫‮[] \u200D‏‬‫‫‫‫⁮‌⁫‏‏‭​‫‏⁯⁪⁪⁪‬⁪​‫‮⁮⁯‫⁫⁭‏‌‍‭​⁭​⁪⁮‍‮;
    internal readonly \u003CModule\u003E.\u206B⁯⁭⁭​‫‍‪‮⁮‌⁮‍‎‍⁯⁯‬⁬⁪‍⁮⁪‫‌‫‪‮⁮‍⁪‎‏⁮‫​‫‭​‫‮[] \u202A‭‬‮‮‫⁫⁫⁬⁭‎​⁯⁭⁪‫⁪‌⁪‌⁪⁭‪‍⁮‮‬‎⁭⁬‮​‬‏‌‭‮⁫‌‏‮;
    internal readonly \u003CModule\u003E.\u206B⁯⁭⁭​‫‍‪‮⁮‌⁮‍‎‍⁯⁯‬⁬⁪‍⁮⁪‫‌‫‪‮⁮‍⁪‎‏⁮‫​‫‭​‫‮[] \u200C‫⁮‍⁭⁫‪⁬⁫⁯⁫‫‫‎⁯‏⁫‭‎‭‌‮‌⁯⁫​⁬​‎⁪‍‌‭⁬⁭​⁬‏​‬‮;
    internal readonly \u003CModule\u003E.\u206B⁯⁭⁭​‫‍‪‮⁮‌⁮‍‎‍⁯⁯‬⁬⁪‍⁮⁪‫‌‫‪‮⁮‍⁪‎‏⁮‫​‫‭​‫‮[] \u206B⁮‏⁮‬‏⁯⁮⁪⁯‭‬⁬‭‭‫⁭‭​‌⁫‎‌⁮‭‭⁮‌‬‌‍‭‫‫‬‏‪⁯‫‮‮;
    internal readonly \u003CModule\u003E.\u206B⁯⁭⁭​‫‍‪‮⁮‌⁮‍‎‍⁯⁯‬⁬⁪‍⁮⁪‫‌‫‪‮⁮‍⁪‎‏⁮‫​‫‭​‫‮[] \u200C⁯‍‬‫‌‎⁭​‏⁭​‏⁪⁭​‏⁫⁭⁮‌‪⁭​‏​⁫‫⁬⁯⁫‍⁭‬‮‌⁪‏‍‪‮;
    internal readonly \u003CModule\u003E.\u200B⁯​⁬‫‬‫⁮​​‌⁬⁮⁪‪‪‎‎⁮‎⁪‌⁭⁭‎‪‏‍⁮‏‌‫⁭⁭‮‍⁪‏⁫‫‮.\u202B⁪‏⁪⁭‫‫⁬‭⁯‎⁮‬‭‎‎‮‪‫‌‬​‬⁮‏⁮⁬‬‎​⁬⁮‍⁯⁬⁯⁫‮⁭‏‮ \u200E‮‮​⁪‎⁮‎⁫‮​‬‬⁯‫‪⁫‪⁪​​⁯⁮‍⁭⁯‭⁫⁬⁭‍⁭⁬‮⁭⁬‏⁫‫⁪‮;
    internal readonly \u003CModule\u003E.\u200B⁯​⁬‫‬‫⁮​​‌⁬⁮⁪‪‪‎‎⁮‎⁪‌⁭⁭‎‪‏‍⁮‏‌‫⁭⁭‮‍⁪‏⁫‫‮.\u202D⁫​‪⁬‭‪⁬⁬⁬‍‭⁫⁫‫⁮⁭⁪‪⁭‮‭⁮‍‍‪⁮⁯‎‎⁯‬⁭‌⁯‫​‌‪‍‮ \u200D​⁮⁮⁮‏⁮⁯‫⁯‪‮‎⁭⁫‏⁯‌‬⁫‬‬⁭⁯‪‫⁯‏⁫‏‌‎‬‮‫‪‫‌‭⁭‮;
    internal readonly \u003CModule\u003E.\u206F⁬‪‫‌⁮⁭‍‍‪​⁮‌‌‫​⁫‮‮​‍‭⁭⁫‌‭‮‫‮⁪​‎⁫‮‏⁪‭⁮⁬‏‮ \u206E‎‌‫‌‌‭​‎⁭⁭⁬⁫‍⁬‫‎‍‌⁪‏⁫⁪‬⁫​‬‎​⁪⁯‪⁮‍‎‪‭⁮‬‬‮;
    internal readonly \u003CModule\u003E.\u206B⁯⁭⁭​‫‍‪‮⁮‌⁮‍‎‍⁯⁯‬⁬⁪‍⁮⁪‫‌‫‪‮⁮‍⁪‎‏⁮‫​‫‭​‫‮[] \u202A‭‎‌‭‬⁭⁬‭‬⁬‫⁮‎​‍‬‮⁬⁪⁫‎‌‬‌⁪⁬⁭⁬⁫⁫‍‏⁯⁯⁫⁬​‫⁫‮;
    internal readonly \u003CModule\u003E.\u202D‌⁪⁫⁭‌‫⁮‎⁮‍‮⁯‬‫‭⁯‍⁮⁫‭⁯‌⁯⁭⁬‎‭⁮‪⁯⁬⁮⁪‏⁯⁮⁯⁫‌‮[] \u202C⁯‮⁫‌⁮‍‏‍‭⁪‬‫‪‫⁯⁭‭‪‌⁪‭‫‫⁬⁫⁯‮⁬‏‭⁫‌‌⁪‎⁭‭‏‪‮;
    internal readonly \u003CModule\u003E.\u202C‬‬‎⁯⁯‌‍‏⁭⁮‮⁯⁯⁫‌‌‬⁯⁫​⁮‏⁬⁫‍⁬‪‎‌‍‏‬‬⁯‪⁬⁬‬⁭‮ \u206E⁬‪‫⁯‍⁯‪⁭⁭⁪‫‬‭‪⁮⁭‬‭⁬‌‫‬‪⁬‏⁪⁪‪⁬⁫‎⁯‪‫‏⁫⁫‪‪‮;
    internal readonly \u003CModule\u003E.\u200B⁯​⁬‫‬‫⁮​​‌⁬⁮⁪‪‪‎‎⁮‎⁪‌⁭⁭‎‪‏‍⁮‏‌‫⁭⁭‮‍⁪‏⁫‫‮.\u202B⁪‏⁪⁭‫‫⁬‭⁯‎⁮‬‭‎‎‮‪‫‌‬​‬⁮‏⁮⁬‬‎​⁬⁮‍⁯⁬⁯⁫‮⁭‏‮ \u206B‪‪‭⁯⁭‍‎‭‪‪⁮⁫⁪⁭​‬‍​⁫‎‎⁭⁭⁬‎⁪‎‮⁯⁯‬‍‬‪‬⁫⁬‍⁫‮;
    internal bool \u202C‏‎​‬‫‪‎‮‏‎‎⁯⁭⁮⁫‮‭‮‌⁪⁪‍⁬‪‮⁪⁮‌‏‪‪‎⁪⁪‏‫⁪⁬⁬‮;
    internal uint \u202D‫‌​⁭‬‪‍‬‬‌‭‌‏‏⁬‫⁯‍⁭‎⁬‬‫⁭⁯‌‬‍‬​‫‬⁮‍⁬⁪‬⁫⁪‮;
    internal uint \u200B⁮‭‮‍‬‫⁯⁯‪‬​‌⁬‫⁪⁮⁫‍⁪‭‍⁬⁪‪‫‎‮‌‪​⁭‫‏⁬⁪⁬‏‌‏‮;
    internal \u003CModule\u003E.\u202D‌⁪⁫⁭‌‫⁮‎⁮‍‮⁯‬‫‭⁯‍⁮⁫‭⁯‌⁯⁭⁬‎‭⁮‪⁯⁬⁮⁪‏⁯⁮⁯⁫‌‮ \u202A⁮‬‍‭‭⁮‮‪‌⁭⁬‬‌⁮⁪‍‬‏‫‭‌‮‍‎‪⁯​‮‎‏‫​‬⁯‭⁬‍‪‍‮;
    internal uint \u206E‌​‫‭⁯⁫‏‬‮‏​​‌‌‎‮​‫⁫⁭⁪⁯⁯⁫‬‬‌‍‍⁫‏‭‏⁭‭⁭⁯⁫‮;

    internal \u200B⁯​⁬‫‬‫⁮​​‌⁬⁮⁪‪‪‎‎⁮‎⁪‌⁭⁭‎‪‏‍⁮‏‌‫⁭⁭‮‍⁪‏⁫‫‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202E‭⁬‌‮‍⁫‪‬‪‪‎‫⁬⁮⁪‏⁯‌⁮‪‭‎‍‍​‌‬⁫‪⁯‪⁭‬⁪⁯⁮‎‌⁮‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200E⁭‭‫‌⁪‫‏⁬⁬‍‌⁬‬⁮‌‌‪⁮​⁭‭‭⁭‎⁪‮​‍⁮‭‮‬⁪‬‏‏⁫⁪‮([In] int obj0, [In] int obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202E‭‌⁬‭‍‬‫⁮​‎‌⁯⁮⁭⁬⁭‫‮‎⁪‌⁪‏‫⁪‪‮⁪‎⁬⁪‮‫​‮‮‭⁮‬‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200B‫‮‎​‌​‮​⁯⁮‌‏⁯‌‍‌⁬‍‌⁫​⁬‌⁯⁮⁬‫​⁪‎⁯⁭‍⁬‫⁭‮‮⁮‮([In] Stream obj0, [In] Stream obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206C‭​⁮⁫⁯‬‭‎⁭‪‍⁮‪‏⁭⁬⁯‏⁫‮‪​⁯‍‏⁫‍​⁯⁭‮‭‮⁫⁪⁬‬⁫‬‮([In] Stream obj0, [In] Stream obj1, [In] long obj2, [In] long obj3)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200F‮‫‏⁬​‫‍⁯⁭‭‎⁮‭‏‭​‎⁪⁫‫⁯⁫‍⁭‪‪‎⁭‏⁭⁭‎‭‏⁬⁯⁪​⁮‮([In] byte[] obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static uint \u202E⁬⁯‌‭⁭⁫‎​‎‎‪‏⁫‭‭⁯‎‭⁯‍‎⁬‭⁬⁯‫⁬‮​‍⁯‬​‫⁭‏‍‌‬‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal class \u202B⁪‏⁪⁭‫‫⁬‭⁯‎⁮‬‭‎‎‮‪‫‌‬​‬⁮‏⁮⁬‬‎​⁬⁮‍⁯⁬⁯⁫‮⁭‏‮
    {
      internal readonly \u003CModule\u003E.\u202D‌⁪⁫⁭‌‫⁮‎⁮‍‮⁯‬‫‭⁯‍⁮⁫‭⁯‌⁯⁭⁬‎‭⁮‪⁯⁬⁮⁪‏⁯⁮⁯⁫‌‮[] \u200E‎‮⁭‭⁮‪‮‫‬‬⁪‌‭‍‮‮‍‬‌​‎⁪⁮⁭⁫‬​‪⁯⁫⁮‏‏‍‍‭⁪‎⁫‮;
      internal readonly \u003CModule\u003E.\u202D‌⁪⁫⁭‌‫⁮‎⁮‍‮⁯‬‫‭⁯‍⁮⁫‭⁯‌⁯⁭⁬‎‭⁮‪⁯⁬⁮⁪‏⁯⁮⁯⁫‌‮[] \u200F‪⁯‬‫‮‬⁮‭⁭‬⁮‫‎‌⁪⁪‍⁯⁪⁭‮‭‍⁬⁬​‎‏‎⁫⁮⁮⁪‭‪‎⁯⁫‮‮;
      internal \u003CModule\u003E.\u206B⁯⁭⁭​‫‍‪‮⁮‌⁮‍‎‍⁯⁯‬⁬⁪‍⁮⁪‫‌‫‪‮⁮‍⁪‎‏⁮‫​‫‭​‫‮ \u200C‭⁯‌‏‌‏⁬‫‪​‪‏⁫‎‫‬​⁬‬‎⁮‪‏⁯​‪‮‏⁪‪‎​‏⁭‫⁪‪⁪‎‮;
      internal \u003CModule\u003E.\u206B⁯⁭⁭​‫‍‪‮⁮‌⁮‍‎‍⁯⁯‬⁬⁪‍⁮⁪‫‌‫‪‮⁮‍⁪‎‏⁮‫​‫‭​‫‮ \u202C​⁫⁬‍‬‍‮⁪‬‍‍‬‫‍‬⁪⁪⁮⁮‎⁫⁬‍⁪⁯​‏⁯⁮‬‬⁪⁬‏‫⁯‍‪‬‮;
      internal \u003CModule\u003E.\u202D‌⁪⁫⁭‌‫⁮‎⁮‍‮⁯‬‫‭⁯‍⁮⁫‭⁯‌⁯⁭⁬‎‭⁮‪⁯⁬⁮⁪‏⁯⁮⁯⁫‌‮ \u206A‮‫‎‭⁫‍‬⁯‪⁯‎⁯⁫​‎⁫⁬⁫⁫​⁪‮‌⁬‫⁭‫‌⁮‪‍‎‫⁮‎‫‫‮;
      internal uint \u202B⁭‪⁬⁮‭‏‬⁮‍⁯​⁪⁬‭‌‪⁭‪⁫‬⁫⁬​‎‎‮⁪‌‪​‮‎⁬⁫‬⁮‭⁭⁮‮;

      internal void \u206B⁯‏‪⁮​‍‌‎‌‭‮​​‌⁪⁮⁭⁬‍⁬⁫‫‍‮⁯‮⁮‎‏⁮⁫‏⁮⁮⁭‮‪​⁬‮([In] uint obj0)
      {
        // ISSUE: unable to decompile the method.
      }

      internal void \u200B⁪​⁪⁭⁭‮⁯⁯‮‮⁪⁭​‬⁪‭⁯‮‭‭‎​⁫⁮‏⁫⁪⁭⁬‏‏‌‍‎⁮‭⁭⁮⁫‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal uint \u202D​‬‪‬‮‭‍‭‮⁫⁬‫‫​⁪⁬‎‪⁫‍‭‍⁯⁭‏‮⁯‭‍‫‬⁯⁮‎⁪⁬‬⁬‬‮([In] \u003CModule\u003E.\u202C‬‬‎⁯⁯‌‍‏⁭⁮‮⁯⁯⁫‌‌‬⁯⁫​⁮‏⁬⁫‍⁬‪‎‌‍‏‬‬⁯‪⁬⁬‬⁭‮ obj0, [In] uint obj1)
      {
        // ISSUE: unable to decompile the method.
      }

      internal \u202B⁪‏⁪⁭‫‫⁬‭⁯‎⁮‬‭‎‎‮‪‫‌‬​‬⁮‏⁮⁬‬‎​⁬⁮‍⁯⁬⁯⁫‮⁭‏‮()
      {
        // ISSUE: unable to decompile the method.
      }
    }

    internal class \u202D⁫​‪⁬‭‪⁬⁬⁬‍‭⁫⁫‫⁮⁭⁪‪⁭‮‭⁮‍‍‪⁮⁯‎‎⁯‬⁭‌⁯‫​‌‪‍‮
    {
      internal \u003CModule\u003E.\u200B⁯​⁬‫‬‫⁮​​‌⁬⁮⁪‪‪‎‎⁮‎⁪‌⁭⁭‎‪‏‍⁮‏‌‫⁭⁭‮‍⁪‏⁫‫‮.\u202D⁫​‪⁬‭‪⁬⁬⁬‍‭⁫⁫‫⁮⁭⁪‪⁭‮‭⁮‍‍‪⁮⁯‎‎⁯‬⁭‌⁯‫​‌‪‍‮.\u200B⁪​⁭‫‎⁯‎‏‭⁮‌‭‍‪‌‬‌‎⁯⁫⁮⁮‌‍‪‭⁮‮⁬⁭‬​‮⁮‭‎​‬‬‮[] \u206B⁯​​‭⁭⁯‌‪‬⁮⁪‌‬⁯‌‍⁮⁪⁭⁮‮‎‬‬‍‮‏‮⁫‎‭‮‮‮‭‫‎‎‮‮;
      internal int \u206F‬‏‮‏‮‪‮‬​​⁫‎⁯⁫‫‭‭‎⁫‫‬‭‪‎‮‭‬‪‬⁭‭‭‫‫‭⁮⁯⁯⁮‮;
      internal int \u206E‫‎‎‏‌‮⁫⁭‎‍‬⁭​‏⁭⁯‪‮⁬‏‍‫‭‬‎⁭⁮‪‬‎‬⁫⁯⁮‫‪‬​‬‮;
      internal uint \u202D‏‎‬‭⁪‪‍‌⁫‏‏‭‎‎‏‮‌‏⁭‏‌‌⁭‭‮‍‭⁫⁯⁮‍‭‎‮‎‏⁭⁬‪‮;

      internal void \u206B‌⁫⁮⁪⁮⁯⁯‬⁬⁫‭⁭‏‎‫⁫⁬‮⁫​‪‪‪⁫‍‍‫‫‎⁯⁮‏‍‏‍⁫⁬⁭‮‮([In] int obj0, [In] int obj1)
      {
        // ISSUE: unable to decompile the method.
      }

      internal void \u206F‮‍⁫⁭‌⁪⁮‎⁪⁫‌⁭⁫‌‮⁪‬‪⁬‫⁯‫‎‬‮⁪⁭‫‎⁪‬‌‎‍⁫‫⁫⁬⁮‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal uint \u206F⁯‬‫‏‏‭‬⁪‌‪‭‬⁫⁬‎‌⁬‌‏⁫‌​‮⁮⁫‏⁯‬‪⁭⁮⁭⁮‭‮⁪​‬⁪‮([In] uint obj0, [In] byte obj1)
      {
        // ISSUE: unable to decompile the method.
      }

      internal byte \u206B⁫⁮⁫​​⁪‮‌⁬‬‪⁯‏​‬⁫‫⁯‪⁬⁪⁭‮⁫⁪‏⁪⁬⁪⁬⁭‏‬‬⁭⁯⁮‫⁭‮([In] \u003CModule\u003E.\u202C‬‬‎⁯⁯‌‍‏⁭⁮‮⁯⁯⁫‌‌‬⁯⁫​⁮‏⁬⁫‍⁬‪‎‌‍‏‬‬⁯‪⁬⁬‬⁭‮ obj0, [In] uint obj1, [In] byte obj2)
      {
        // ISSUE: unable to decompile the method.
      }

      internal byte \u202C‮‎‎‫‮⁯‮‪⁫‪‏⁬⁪‍‏‏⁬⁪⁮⁭‮⁯​‌⁮‎‏‏‌⁪‫‫‍‎‮‌‎⁯⁭‮([In] \u003CModule\u003E.\u202C‬‬‎⁯⁯‌‍‏⁭⁮‮⁯⁯⁫‌‌‬⁯⁫​⁮‏⁬⁫‍⁬‪‎‌‍‏‬‬⁯‪⁬⁬‬⁭‮ obj0, [In] uint obj1, [In] byte obj2, [In] byte obj3)
      {
        // ISSUE: unable to decompile the method.
      }

      internal \u202D⁫​‪⁬‭‪⁬⁬⁬‍‭⁫⁫‫⁮⁭⁪‪⁭‮‭⁮‍‍‪⁮⁯‎‎⁯‬⁭‌⁯‫​‌‪‍‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal struct \u200B⁪​⁭‫‎⁯‎‏‭⁮‌‭‍‪‌‬‌‎⁯⁫⁮⁮‌‍‪‭⁮‮⁬⁭‬​‮⁮‭‎​‬‬‮
      {
        internal \u003CModule\u003E.\u206B⁯⁭⁭​‫‍‪‮⁮‌⁮‍‎‍⁯⁯‬⁬⁪‍⁮⁪‫‌‫‪‮⁮‍⁪‎‏⁮‫​‫‭​‫‮[] \u200B⁭⁪⁪‎‏⁭⁭‌⁪⁮⁫‌‪‮‍⁯⁪​‏⁪‫‍‬‎‌‍‌‮‫​⁯⁪⁭⁯‮‬‏⁪‌‮;

        internal void \u206E‏⁮⁮⁬‎‮⁬‏‏‏⁪‬⁪‭‬⁮‎⁬‌‪‍⁬⁪⁭‮⁫‮⁮​⁯‬‌⁮⁪‌⁭‪‏⁫‮()
        {
          // ISSUE: unable to decompile the method.
        }

        internal void \u206A‪‎‮‎​‭‫‭‏‬⁯‍‏‍‫​⁮‎‪‮‭‫‫‫​⁪‫‍⁯⁪⁫⁯‬‍‮‍⁫‬‮()
        {
          // ISSUE: unable to decompile the method.
        }

        internal byte \u206A​‍‍‏​⁬‌‪‪⁭⁯⁯⁪‌‫⁪‬​⁪⁫‮‬‫‭‫‭⁭‬⁯⁬⁬‌‏‎‪‌‭‬⁯‮([In] \u003CModule\u003E.\u202C‬‬‎⁯⁯‌‍‏⁭⁮‮⁯⁯⁫‌‌‬⁯⁫​⁮‏⁬⁫‍⁬‪‎‌‍‏‬‬⁯‪⁬⁬‬⁭‮ obj0)
        {
          // ISSUE: unable to decompile the method.
        }

        internal byte \u200D⁮⁯‬⁮‭‬⁭⁭‏⁪‮⁫⁪‪⁪‫⁯‫​⁮‎⁪‪⁪‪⁬‎⁮‪‭⁬⁪‮⁮⁯‍‏‮‫‮([In] \u003CModule\u003E.\u202C‬‬‎⁯⁯‌‍‏⁭⁮‮⁯⁯⁫‌‌‬⁯⁫​⁮‏⁬⁫‍⁬‪‎‌‍‏‬‬⁯‪⁬⁬‬⁭‮ obj0, [In] byte obj1)
        {
          // ISSUE: unable to decompile the method.
        }
      }
    }
  }

  internal class \u206F⁬‪‫‌⁮⁭‍‍‪​⁮‌‌‫​⁫‮‮​‍‭⁭⁫‌‭‮‫‮⁪​‎⁫‮‏⁪‭⁮⁬‏‮
  {
    internal byte[] \u200E⁭⁫‪‎⁫⁭​⁯‍⁪⁯⁫⁭​⁮‬⁮⁮⁪‍‌⁪‫⁬‭⁭⁬‌‎‭⁭‬⁫​‬‭⁮‮;
    internal uint \u202A‫‏⁯‌‮⁯‪⁬⁮⁫⁬⁬‍⁬‭‮‌⁫​‎‍‪‪​⁮‪‍‭‭⁭​​‏‏‍‏‫⁭⁫‮;
    internal Stream \u200E​​⁫‪‏‌​‭‪⁫⁬‭​⁬⁪‬‍⁭​‮⁯‍‪‍⁭‪‫⁭‍‫⁬⁭‎‪​‏⁭⁮‌‮;
    internal uint \u206A⁭​⁫⁮‎⁪‭⁮‍⁯⁯⁮‭⁬‬‌⁫‪⁬⁯⁭‏‎⁮​‮⁭⁯‎‏‍‏‎‭‮‍‏⁪‪‮;
    internal uint \u206E⁭‍‭‮⁯⁫‎​⁪‌⁪​⁮‎⁫⁬⁭​‌‏‏‮⁪⁫⁫⁫⁭‎⁫‌⁪‍⁮‮‮‎‏⁪‏‮;

    internal void \u200E​⁪​‎⁪‮‭‭‎‎⁬‌⁪‌⁬⁮⁭⁬‮‫‪⁫‍‫⁪‎⁮⁯⁭‏⁭⁯⁭⁪⁫‭‫‮⁬‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206D‮‭‭‮⁭‎‬⁮⁬‬​‍‪‎‎‎⁬⁫⁪‌​‪⁮⁭‏‌‌⁭⁭‎⁯‬‬​‪‭⁭⁯‮([In] Stream obj0, [In] bool obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200E⁮⁮​‫‌‏⁮‌⁭​⁪​‍‎‭⁮⁯⁬‏​‎‭‍​‬‍‌⁮⁮⁭‬‎⁯‬⁪⁫⁯⁪⁯‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200E‫‮‬‏⁪‮‏‎⁫‏‪‍‭⁯‪​⁬⁯‎​⁭‪‍‫‌‎​⁫‭‬‮⁫⁮‏‏⁮‫‍‭‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200F‎⁮‪‬⁮‍‫‮‬‌‏​‬‮‎‪⁭⁯⁮‪‫⁫​​‎⁯⁮‍⁪‪⁫‪‏⁮‫⁪‌‫⁭‮([In] uint obj0, [In] uint obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200D‪⁭⁬⁬⁪⁫⁯⁪‎​‭‏⁯‭⁭​⁬‌‬‫‎‎⁭‎‬‭⁫‫⁯‮⁯‏‬⁫‮⁬‎⁬⁯‮([In] byte obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal byte \u202A⁬⁮‭‫‍‭‪‎‎​‫‭​‎​⁭⁭‬‮‎‭⁫‬⁯‪⁭⁬‎‮‎⁫‮⁪‍⁫‮⁯⁪‮‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal \u206F⁬‪‫‌⁮⁭‍‍‪​⁮‌‌‫​⁫‮‮​‍‭⁭⁫‌‭‮‫‮⁪​‎⁫‮‏⁪‭⁮⁬‏‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal struct \u200D‌‭⁫‌⁭‎‮‫‎⁫‪⁫​‭‮‌‭‪⁬⁭‎‎‪‭​⁯‍‫‮‌⁭⁫⁭‬‌‎‫⁯‭‮
  {
    internal uint \u206A‌⁭⁭⁬⁭‭‍‫‌‎‍⁫⁫⁮​‪‪​⁪⁪‍⁯‫​‮‎⁫‮⁫‏⁮‌‪‎‏​‍‫⁫‮;

    internal void \u206C⁫⁮‏⁭‏‮‭‬⁫⁫‭⁭⁭‍‮‍⁭‎​‍⁫⁫‭‍‭‍‬‌‫‭⁬⁮⁭‮⁪‍⁫⁭‭‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202C​⁭‭⁫⁫‮⁪⁫‎‏‬​​‎‌⁫‫⁮‬⁯‍‍​⁪‪​‍‍⁭‬⁬⁮‫⁬‪⁯‮‬‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200F⁬⁮‏⁭‪⁫⁪⁪‭⁮⁬‫⁬‍​⁯⁬‫‌​⁪‏‌​⁪‭‫‍⁪⁬‫‬‭‪‌‫‮‮⁫‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202E‮⁭‫​⁭‪‫‌‮‏⁭⁯⁮‏‬‫⁪‮‭‭‌⁬⁪‏‬⁯‪⁪‍⁫‫⁫‭⁬‌‭⁭‎‬‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206D⁫‮‮‏‪‭‌‌‫‎⁫‎⁭​‬‭‭⁭​‬‎⁬‭‏⁮‫‭‎⁭⁬‌⁬‍⁭⁬⁯‏‎‎‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal bool \u206E‮‍‏⁫‮‎‍⁯‮‍⁭‪⁯​‪⁯‏⁬⁫⁭⁮​⁪‎⁫⁮‎⁮‌⁫‌​‌⁫⁭​‮‫‬‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  [StructLayout(LayoutKind.Explicit, Size = 19456)]
  internal struct \u200F‎‬‮⁪‎​‌‏‪⁫‫‭‫‬⁫‭⁭‭‍⁫⁮‍‏‬⁬⁮⁪‫‍⁭‏‍‍‪⁫⁯‍​‮‮
  {
  }

  [StructLayout(LayoutKind.Explicit, Size = 8000, Pack = 1)]
  internal struct \u202E​⁮⁭⁭​‫⁭‫⁫‍‮‏‍‌‫‪‪⁯‬‭‏‮⁬​‫‭‌⁪‪‍⁫⁬⁯‪‎⁮‌‍‮
  {
  }
}
